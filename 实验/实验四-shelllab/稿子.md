## eval函数

1. 定义一些变量和数据结构，包括存放解析参数的字符串数组`argv`，工作状态`state`，信号集`set`和进程ID`pid`等。
2. 解析命令行输入，将解析后的参数存储在`argv`数组中，并确定工作状态（前台或后台）。
3. 如果命令行为空，则直接返回。
4. 如果不是内置命令，执行以下操作：
   - 初始化信号集`set`（如果返回值为 -1 说明失败，则报告错误并返回）
   - 并向其中添加SIGINT、SIGTSTP和SIGCHLD信号（如果返回值为 -1 说明失败，则报告错误并返回）。
   - 在派生子进程之前，使用`sigprocmask`函数阻塞SIGCHLD信号，以防止竞争条件。
   - 使用`fork`函数创建子进程。
   - 如果`fork`创建子进程失败，则报告错误并返回。
   - 如果子进程创建成功（pid为0），则执行以下操作：
     - 解除对SIGCHLD信号的阻塞。
     - 将当前进程（子进程）的进程组ID设置为当前进程的进程ID，即将子进程作为一个独立的进程组。
     - 使用`execve`函数执行解析后的命令行参数，如果执行失败，则报告命令未找到的错误信息并退出子进程。
   - 将当前进程（父进程）添加到作业列表中，无论是前台还是后台进程。
   - 恢复对SIGINT、SIGTSTP和SIGCHLD信号的阻塞。
   - 根据工作状态，对子进程进行不同的处理：
     - 如果是前台作业，则调用`waitfg`函数等待子进程的结束。
     - 如果是后台作业，则打印作业信息，包括作业ID、进程ID和命令行。
5. 函数结束并返回。

## builtin_cmd函数

1. 接收一个参数`argv`，这是一个字符串数组，包含解析后的命令及其参数。
2. 使用`strcmp()`函数将`argv[0]`与内置命令"quit"进行比较。如果`argv[0]`与"quit"相等，即输入的命令是"quit"，则调用`exit(0)`函数退出程序。
3. 如果`argv[0]`与"bg"或"fg"相等，即输入的命令是"bg"或"fg"，则调用`do_bgfg(argv)`函数执行相应的操作
4. 如果`argv[0]`与"jobs"相等，即输入的命令是"jobs"，则调用`listjobs(jobs)`函数列出正在运行和停止的后台作业。
5. 如果以上情况都不符合，即输入的命令不是内置命令，则返回0表示不是内置命令。
6. 返回1表示是内置命令。

## do_bgfg函数

1. 接收一个参数`argv`，这是一个字符串数组，包含解析后的命令及其参数。
2. 检查是否存在参数，即检查`argv[1]`是否为空。如果为空，打印错误消息并返回。
3. 检查参数的格式，判断是作业ID（以`%`开头的数字）还是进程ID（纯数字）。
   - 如果参数是作业ID，通过将`argv[1]`转换为整数，并使用`strtol()`函数，将数字部分解析为作业ID。如果解析失败（`num <= 0`），打印错误消息`"%s: argument must be a PID or %%jobid\n"`，其中`%s`会被替换为命令名，然后返回。如果解析成功，通过调用`getjobjid(jobs, num)`函数获取对应的作业结构体指针。如果作业不存在，打印错误消息`"%%%d: No such job\n"`，其中`%d`会被替换为作业ID，然后返回。
   - 如果参数是进程ID，通过将`argv[1]`转换为整数，并使用`strtol()`函数，将数字部分解析为进程ID。如果解析失败（`num <= 0`），打印错误消息`"%s: argument must be a PID or %%jobid\n"`，其中`%s`会被替换为命令名，然后返回。如果解析成功，通过调用`getjobpid(jobs, num)`函数获取对应的作业结构体指针。如果进程不存在，打印错误消息`"(%d): No such process\n"`，其中`%d`会被替换为进程ID，然后返回。
4. 根据命令类型执行相应的操作：
   - 如果命令是"bg"，将作业状态设置为后台执行，并发送`SIGCONT`信号给作业的进程组以恢复执行。然后打印作业信息。
   - 如果命令是"fg"，将作业状态设置为前台执行，并发送`SIGCONT`信号给作业的进程组以恢复执行。然后等待前台作业结束，通过调用`waitfg(job->pid)`函数实现。
   - 如果以上情况都不符合，打印错误消息`"do_bgfg: Internal error"`，然后调用`exit(0)`退出程序。

## waitfg函数

1. 根据给定的子进程的进程ID `pid`，使用 `getjobpid` 函数获取与该子进程相关联的作业信息，存储在指针 `job` 中。
2. 如果未找到与子进程关联的作业信息（即 `job` 为 `NULL`），则直接返回。
3. 进入循环，只要当前子进程的状态仍然是前台运行状态（`job->state == FG`），就调用 `sleep(1)` 函数使当前进程休眠1秒，以等待子进程的状态改变。
4. 当子进程的状态改变时，循环条件不再满足，跳出循环。
5. `return`

## sigchld_handler函数

1. 声明变量 `status` 用于存储子进程的状态信息，`jid` 存储作业 ID，`pid` 存储子进程的进程 ID，`job` 存储与子进程相关的作业信息。

2. 如果设置了 `verbose` 标志，打印进入信号处理函数的消息。

3. 进入`while`循环，调用 `waitpid(-1, &status, WNOHANG | WUNTRACED)` 等待任意子进程的状态改变。其中，`-1` 表示等待任意子进程，`WNOHANG` 表示以非阻塞方式等待，`WUNTRACED` 表示在子进程停止时立即返回。

4. 检查 `waitpid()` 的返回值 `pid`，如果 `pid` 大于0，表示成功等到了一个子进程的状态改变。

5. 调用 `getjobpid(jobs, pid)` 函数查找与给定进程ID `pid` 相关联的作业。如果找到该作业并成功返回作业结构体指针，则将其赋值给变量 `job`。如果找不到与进程ID `pid` 相关联的作业（即 `job` 的值为 `NULL`），则表示发生了错误。打印一条错误消息，指示无法跟踪（lost track of）进程ID `pid`，并返回。如果成功找到了作业，将作业ID `jid` 设置为作业结构体 `job` 的作业ID。

6. 根据子进程的三种状态进行相应的处理：

   - 如果子进程收到了一个暂停信号（`WIFSTOPPED(status)` 为真），表示子进程被暂停，打印作业暂停的相关信息，包括作业 ID、子进程的进程 ID、导致暂停的信号编号，并将作业状态设为挂起（`ST`）。

   - 如果子进程通过调用 `exit` 或者返回正常终止（`WIFEXITED(status)` 为真），表示子进程正常终止，接着调用 `deletejob(jobs, pid)` 函数，尝试从作业列表 `jobs` 中删除与给定进程ID `pid` 相关联的作业。如果删除成功，则返回非零值，表示作业已成功删除。

     如果作业删除成功，并且 `verbose` 标志为真（即需要详细输出），则输出两行消息：

     - 第一行打印作业的信息，包括作业ID `jid`、进程ID `pid` 和命令状态 "deleted"。
     - 第二行打印作业的终止状态，包括作业ID `jid`、进程ID `pid` 和进程的退出状态 `WEXITSTATUS(status)`。

   - 如果子进程是因为一个未被捕获的信号终止，例如 `SIGKILL`（`WIFSIGNALED(status)` 为真），表示子进程被一个信号终止，接着调用 `deletejob(jobs, pid)` 函数，尝试从作业列表 `jobs` 中删除与给定进程ID `pid` 相关联的作业。如果删除成功，则返回非零值，表示作业已成功删除。

     如果作业删除成功，并且 `verbose` 标志为真（即需要详细输出），则打印一行消息，显示作业的信息，包括作业ID `jid`、进程ID `pid` 和状态 "deleted"。

     然后，打印一行消息，显示作业的终止信息，包括作业ID `jid`、进程ID `pid` 和导致子进程终止的信号的数量 `WTERMSIG(status)`。

7. 重复while循环（4-6），直到没有子进程的状态改变或出现错误。

8. 如果`verbose` 标志为真，打印退出信号处理函数的消息。

9. `return`返回。

## sigint_handler函数

1. 如果全局变量 `verbose` 为真，则输出进入信号处理程序的消息。
2. 调用 `fgpid(jobs)` 函数获取当前前台作业的进程ID（PID），将其赋值给变量 `pid`。
3. 如果获取到了有效的进程ID（即 `pid` 不为0），则表示存在前台作业。
4. 使用 `kill(-pid, SIGINT)` 将 `SIGINT` 信号发送给前台进程组内的所有进程，包括前台进程及其子进程。通过将进程ID取反传递给 `kill` 函数，可以将信号发送给整个进程组。
   - 如果发送信号失败，则输出错误消息并终止程序。
5. 如果全局变量 `verbose` 为真，则输出前台作业被终止的消息。
6. 如果全局变量 `verbose` 为真，则输出离开信号处理程序的消息。
7. `return`返回。

## sigtstp_handler函数

1. 如果全局变量 `verbose` 为真，则输出进入信号处理程序的消息。
2. 调用 `fgpid(jobs)` 函数获取当前前台作业的进程ID（PID），将其赋值给变量 `pid`。
3. 使用 `getjobpid(jobs, pid)` 获取具有给定进程ID的作业结构体指针，将其赋值给变量 `job`。
4. 如果获取到了有效的进程ID（即 `pid` 不为0），则表示存在前台作业。
5. 使用 `kill(-pid, SIGTSTP)` 将 `SIGTSTP` 信号发送给前台进程组内的所有进程，包括前台进程及其子进程。通过将进程ID取反传递给 `kill` 函数，可以将信号发送给整个进程组。
6. 如果发送信号失败，则输出错误消息并终止程序。
   - 如果全局变量 `verbose` 为真，则输出前台作业被停止的消息，包括作业的Job ID和进程ID。
7. 如果全局变量 `verbose` 为真，则输出离开信号处理程序的消息。
8. 函数返回。